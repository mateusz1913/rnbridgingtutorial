import CompleteFile from '../_complete-file.mdx';

#### `AppInfoModule.h`

Now, let's move to the module that will manage function calls from the JS world:

```objc title="ios/AppInfoModule.h"
#import <React/RCTBridgeModule.h>

/**
 * Declare the ObjC interface for that native module class.
 * 
 * It must extend NSObject (like every class in ObjC) and
 * implement RCTBridgeModule (like each RN native module).
 */
@interface AppInfoModule : NSObject<RCTBridgeModule>

@end
```

`AppInfoModule` class extends base `NSObject` class (each class in ObjC needs to extend `NSObject`) and implements `RCTBridgeModule` protocol (each RN iOS module needs to implement `RCTBridgeModule` protocol).

#### `AppInfoModule.mm`

```objc title="ios/AppInfoModule.mm"
#import "AppInfoModule.h"

#import "AppInfoModuleImpl.h"

#if RCT_NEW_ARCH_ENABLED
/**
 * Import header file with codegenerated protocols based on the JS specification
 *
 * The name of the header matches the name provided in codegenConfig's `name` field in package.json
 */
#import "AppInfoPackage.h"

/**
 * Each turbo module implements codegenerated spec protocol
 */
@interface AppInfoModule () <NativeAppInfoModuleSpec>
@end
#endif

/**
 * Declare the ObjC implementation for that native module class
 */
@implementation AppInfoModule

/**
 * Return the name of the module - it should match the name provided in JS specification
 */
RCT_EXPORT_MODULE(AppInfoModule)

#if RCT_NEW_ARCH_ENABLED
// Implement RCTTurboModule protocol
- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {
    return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);
}
#endif

@end
```

This is the implementation file for `AppInfoModule` class.

Before declaring the implementation block, we have to import header file for `AppInfoModuleImpl` module-implementation class,
and we have to implement code-generated spec protocol for new architecture (code between `#if RCT_NEW_ARCH_ENABLED` & `#endif` directives).

After that, inside implementation block we have `RCT_EXPORT_MODULE` macro invoked with `AppInfoModule` argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world.

Also, for new architecture, it implements `getTurboModule:` method (from `RCTTurboModule` protocol).
If you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented.

Let's combine module-implementation with RN's wrapper class

```objc title="ios/AppInfoModule.mm"
//

// highlight-start
/**
 * Declare the ObjC implementation for that native module class
 */
@implementation AppInfoModule {
    AppInfoModuleImpl *moduleImpl;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        moduleImpl = [AppInfoModuleImpl new];
    }
    return self;
}
// highlight-end

/**
 * Return the name of the module - it should match the name provided in JS specification
 */
RCT_EXPORT_MODULE(AppInfoModule)

// highlight-start
/**
 * Declare if module should be initialized on the main queue
 */
+ (BOOL)requiresMainQueueSetup
{
    return NO;
}
// highlight-end

//

@end
```

First, we declare private variable on `AppInfoModule` which will be initialized in the `init` method. We can use `AppInfoModuleImpl` ObjC class, because it's imported from `AppInfoModuleImpl.h`.

Next, we override static method `requiresMainQueueSetup`, which must be done whenever `init` method on the RN's wrapper class is overriden. 

Finally, we can register exported methods with `RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD` macro and return value from module-implementation class:

```objc title="ios/AppInfoModule.mm"
//

/**
 * Declare the ObjC implementation for that native module class
 */
@implementation AppInfoModule {
    AppInfoModuleImpl *moduleImpl;
}

// highlight-start
// Exported methods are overriden - based on the spec class
RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)
{
    return [moduleImpl getAppBuildNumber];
}

RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)
{
    return [moduleImpl getAppBundleId];
}

RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)
{
    return [moduleImpl getAppVersion];
}
// highlight-end

//

@end
```

<CompleteFile
  filename="AppInfoModule.mm"
  language="objc"
>

    #import "AppInfoModule.h"

    #import "AppInfoModuleImpl.h"

    #if RCT_NEW_ARCH_ENABLED
    /**
    * Import header file with codegenerated protocols based on the JS specification
    *
    * The name of the header matches the name provided in codegenConfig's `name` field in package.json
    */
    #import "AppInfoPackage.h"

    // Each turbo module implements codegenerated spec protocol
    @interface AppInfoModule () <NativeAppInfoModuleSpec>
    @end
    #endif

    // Declare the ObjC implementation for that native module class
    @implementation AppInfoModule {
        AppInfoModuleImpl *moduleImpl;
    }

    // Return the name of the module - it should match the name provided in JS specification
    RCT_EXPORT_MODULE(AppInfoModule)

    - (instancetype)init {
        self = [super init];
        if (self) {
            moduleImpl = [AppInfoModuleImpl new];
        }
        return self;
    }

    // Declare if module should be initialized on the main queue
    + (BOOL)requiresMainQueueSetup
    {
        return NO;
    }

    // Exported methods are overriden - based on the spec class
    RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)
    {
        return [moduleImpl getAppBuildNumber];
    }

    RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)
    {
        return [moduleImpl getAppBundleId];
    }

    RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)
    {
        return [moduleImpl getAppVersion];
    }

    #if RCT_NEW_ARCH_ENABLED
    // Implement RCTTurboModule protocol
    - (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
        (const facebook::react::ObjCTurboModule::InitParams &)params
    {
        return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);
    }
    #endif

    @end
</CompleteFile>
